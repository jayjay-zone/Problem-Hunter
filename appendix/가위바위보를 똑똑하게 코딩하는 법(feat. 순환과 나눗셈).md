# 가위바위보를 똑똑하게 코딩하는 법 (feat. 순환과 나눗셈)

가위바위보를 함수로 만들다가, 문득 더 간z 나게 코딩할 수 있는 방법이 있지 않을까 고민했다! 몇번 고민했지만 결국 fail...

하지만 나는 구글을 찢어!가 아니라 찾았다!

[출처] ([https://neomindstd.github.io/문제풀이/boj2930/](https://neomindstd.github.io/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/boj2930/))

<aside>
💝 **문제**

한국에 적수가 없다고 판단한 상근이는 세계 대회에 나가기로 했다. 요즘 상근이는 세계 대회를 대비해 훈련중이다. 훈련은 친구 N명과 동시에 한다. 가위바위보는 총 R개의 라운드로 이루어져 있고, 각 라운드마다 상근이와 친구들은 세 모양중 하나를 만들어야 한다.

각 라운드의 점수 계산은 상근이와 친구 개개인을 독립적으로 비교한다. 상근이가 이기면 2점, 비기면 1점, 지면 0점이다.

상근이와 친구들이 각 라운드에 낸 모양이 주어졌을 때, 게임이 끝나고 난 후 상근이의 점수를 구한다. 그 다음, 상근이가 친구들이 무엇을 낼지 미리 알고있었다고 가정할 때, 상근이가 얻을 수 있는 최고 점수를 구하는 프로그램을 작성하시오.

</aside>

**위의 링크에서 제시된 풀이**

```python
r = int(input())
s = input()
n = int(input())
fs = [input() for _ in range(n)]

rsp = {'R':0,'S':1,'P':2}

cs = ms = 0
for i in range(r):
    ts = [[0,'R'],[0,'S'],[0,'P']]
    for j in range(n):
        if (rsp[s[i]] + 1) % 3 == rsp[fs[j][i]]: cs += 2
        elif s[i] == fs[j][i]: cs += 1

        for t in ts:
            if (rsp[t[1]] + 1) % 3 == rsp[fs[j][i]]: t[0] += 2
            elif t[1] == fs[j][i]: t[0] += 1
    ms += max(ts)[0]
print(cs)
print(ms)
```

rsp[k]+1 은 k에 지는 경우를 나타내게 된다.

(rsp[k]+1) 을 3으로 나눈 이유는, 만약 k == 'p' 일때, +1을 하게 되면 3이 되고,
3으로 나눈 나머지를 구하면 0 -> 다시 원점으로 돌아갈 수 있기 때문이다

rsp = {'r':0, 's':1, 'p':2} 에서, 각 원소에 0, 1, 2를 할당한 이유는,  

r > s > p > r 의 승리 관계를 가지기 때문이다. (이때의 x>y는, x가 y에 대해 이긴다는 의미이다)

**예를 들어**

```python
x, y1, y2 = 's', 'p', 'r'

#결과1: x 승리, y1 패배
# 결과2: x 패배, y2 승리

(rsp[x]+1)%3
>>> 2

# (rsp[x]+1)%3의 값과 y가 동일한 경우 승리를 의미한다
print('x:',rsp[x],', y1:', rsp[y1], ', y2:', rsp[y2])
>> x: 1 , y1: 2 , y2: 0
```

좌표 회전도 비슷하게 풀 수 있다.. 그런데 기억이 안난다.. 
[https://programmer-565.tistory.com/20](https://programmer-565.tistory.com/20)

~답변을 기다리는 중…~ -> 참고할 링크를 알려주셨다!!
[https://choichumji.tistory.com/76](https://choichumji.tistory.com/76)

백준 3190 뱀문제에서 예시를 찾을 수 있다
머리의 방향에 따라 갈 수 있는 (상우하좌) 위치가 달라지게 된다.

예를 들어,
- 머리가 오른쪽일 때, 상우하좌이면 -> (0,1), (1,0), (0,-1), (-1,0)
    - 1) (L)머리가 위쪽일 때, 상우하좌이면 -> (-1,0), (0,1), (1,0), (0,-1)
    - 2) (D)머리가 아래쪽일 때, 상우하좌이면 -> (1,0), (0,-1),...
    
이를 일반화 시키면
- L이면 head-=1 -> -1%4 =3 에서 상우하좌 시작
- D이면 head+=1 -> 1%4 = 1 에서 상우하좌 시작

이런 순환 관계를 가지게 된다!!


**즉, 이렇게 각 경우들이 순환관계인 경우, 원소의 개수로 나눈 나머지가 "kick" 이 될 가능성이 높다!**