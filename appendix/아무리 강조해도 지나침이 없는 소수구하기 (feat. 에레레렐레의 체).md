# 아무리 강조해도 지나침이 없는 소수구하기 (feat. 에레레렐레의 체)

https://seongonion.tistory.com/43

### 1. 기본적인 접근 방법
- 냅다 나눠준다

### 2. 유인원에서 원시인으로 진화한 방법
- 약수의 대칭성을 떠올린다.
    - 8의 약수는 1,2,4,8이다. 만약 2로 나누어 떨어지지 않으면, 4로도 나누어 떨어지지 않을 것이다. 또한, 2로 나눠봤다면, 굳이 4로 또 나눌 필요는 없다.
    - 이 점을 활용해서  sqrt(n) 까지만 나눠보면, 그 숫자가 소수인지 아닌지 알 수 있다.


```python
import math

def is_prime(n):
    if n==2 or n==3:
        return True
    
    for i in range(2, int(math.sqrt(n))+1):
        if n%i == 0:
            return False
        else:
            return True
```

### 3. 에네르기의 체를 활용한다
- 참고로 나는 이거 중딩때인가 배울 때부터 생긴게 맘에 안들더라. 지금에 와서도 괴롭힐 줄은 몰랐는데, 역시 관상은 과학이다

1. 2 ~ N까지의 범위가 담긴 배열을 만든다.

2. 해당 배열 내의 가장 작은 수 i 부터 시작하여, i의 배수들을 해당 배열에서 지워준다. (i는 소수이기 때문에 i자체는 지우지 않는다.)

**3. 주어진 범위 내에서 i의 배수가 모두 지워지면 i 다음으로 작은 수의 배수를 같은 방식으로 배열에서 지워준다.**

4. 더 이상 반복할 수 없을 때까지 2, 3번의 과정을 반복해준다.


```python
def is_prime_num(n):
    arr = [True] * (n + 1) # 특정 수가 지워졌는지 아닌지 확인하기 위한 배열
    arr[0] = False
    arr[1] = False

    for i in range(2, n + 1):
        if arr[i] == True: # 특정 수가 지워지지 않았다면 (소수여서)
            # j=1인 경우는 소수니까 지우지 않고, i*j(j=2,3,4,..) 부터는 당연히 소수의 배수들이니까 지워준다
            j = 2
            while (i * j) <= n:
                arr[i*j] = False # i의 배수의 값을 False로 지워준다.
                j += 1

    return arr

```

맞출 수 있었는데, 너무 아쉽구만..


```python

```
